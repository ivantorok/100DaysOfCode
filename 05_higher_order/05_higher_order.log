http://eloquentjavascript.net/05_higher_order.html
2018-02-10 11:33:41
Abstraction
It has to become second nature, for a programmer, to notice when a concept is begging to be abstracted into a new word.
Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions. If you have already accepted the fact that functions are regular values, there is nothing particularly remarkable about the fact that such functions exist. The term comes from mathematics, where the distinction between functions and other values is taken more seriously.
Higher-order functions allow us to abstract over actions, not just values. They come in several forms. For example, you can have functions that create new functions.

function greaterThan(n) {
  return function(m) { return m > n; };
}
var greaterThan10 = greaterThan(10);
console.log(greaterThan10(11));
// → true
And you can have functions that change other functions.

function noisy(f) {
  return function(arg) {
    console.log("calling with", arg);
    var val = f(arg);
    console.log("called with", arg, "- got", val);
    return val;
  };
}
noisy(Boolean)(0);
// → calling with 0
// → called with 0 - got false
You can even write functions that provide new types of control flow.

function unless(test, then) {
  if (!test) then();
}
function repeat(times, body) {
  for (var i = 0; i < times; i++) body(i);
}

repeat(3, function(n) {
  unless(n % 2, function() {
    console.log(n, "is even");
  });
});
// → 0 is even
// → 2 is even





apply


JavaScript functions have an apply method. You pass it an array (or array-like object) of arguments, and it will call the function with those arguments.
Now... This is beyond me at this point... maybe later it will become more clear:


function transparentWrapping(f) {
  return function() {
    return f.apply(null, arguments);
  };
}
That’s a useless function, but it shows the pattern we are interested in—the function it returns passes all of the given arguments, and only those arguments, to f. It does this by passing its own arguments object to apply. The first argument to apply, for which we are passing null here, can be used to simulate a method call. We will come back to that in the next chapter.


JavaScript gives us functions, JSON.stringify and JSON.parse, that convert data to and from this format. The first takes a JavaScript value and returns a JSON-encoded string. The second takes such a string and converts it to the value it encodes
2018-02-10 12:29:24


2018-02-11 10:18:52
Read through https://www.w3schools.com/js/js_function_apply.asp. Apply is still beyond my comprehension. (I will make sure to celebrate when I finally understand it enough to be able to apply it when needed.)

forEach
filter
map


Like forEach and filter, map is also a standard method on arrays.

2018-02-11 11:26:19 
I gotta stop here, as it has been more than an hour for today.
It was interesting.
2018-02-12 15:38:27

Okay, that was interesting. I am not sure what I have learned. Maybe tomorrow it will distill to something I can express verbally. Or maybe later...
2018-02-12 16:38:19
2018-02-16 08:21:51
For example, the following code finds the percentage of a person’s known ancestors who lived past 70 (by lineage, so people may be counted multiple times):

https://twitter.com/steveluscher/status/741089564329054208
http://www.globalnerdy.com/2016/06/23/map-filter-and-reduce-explained-using-emoji/
http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/06/map-filter-reduce-in-emoji-1.png

Binding


console.log(ancestry.filter(isInSet.bind(null, theSet)));
// → … same result
The call to bind returns a function that will call isInSet with theSet as first argument, followed by any remaining arguments given to the bound function.

The first argument, where the example passes null, is used for method calls, similar to the first argument to apply. I’ll describe this in more detail in the next chapter.

SUMMARY:
Functions as arguments for other functions enable us to work with incomplete pieces of code, where the missing computation is passed to the function from other parts of the cod e (from a situation where those computations are better defined).
Arrays: forEach, filter, map, reduce
Functions: apply, bind


Exercises
Flattening
Use the reduce method in combination with the concat method to “flatten” an array of arrays into a single array that has all the elements of the input arrays.

var arrays = [[1, 2, 3], [4, 5], [6]];
// Your code here.
// → [1, 2, 3, 4, 5, 6]

function flattenArrayDebug(array) {
	return array.reduce(function (a, b) {
        return a = a.concat(b);
    });
};
undefined
flattenArrayDebug(arrays);
(6) [1, 2, 3, 4, 5, 6]
console.log(flattenArrayDebug(arrays));
VM4191:1 (6) [1, 2, 3, 4, 5, 6]0: 11: 22: 33: 44: 55: 6length: 6__proto__: Array(0)
undefined

2018-02-16 09:30:37 
For me the takeaway is the same again: read slowly and carefully. It pays off. Gotta stop here.
2018-02-16 09:31:59
2018-02-19 18:53:48

Mother-child age difference
Using the example data set from this chapter, compute the average age difference between mothers and children (the age of the mother when the child is born). You can use the average function defined earlier in this chapter.

Note that not all the mothers mentioned in the data are themselves present in the array. The byName object, which makes it easy to find a person’s object from their name, might be useful here.

function average(array) {
  function plus(a, b) { return a + b; }
  return array.reduce(plus) / array.length;
}

var byName = {};
ancestry.forEach(function(person) {
  byName[person.name] = person;
});

// Your code here.

// → 31.2




2018-02-19 20:01:12
could not finish it completely, but the partial result is here:
function mothersAgeAtBirth(person) {
    if (!(person.mother === null) && !(byName[person.mother] === undefined))
        return person.born - mothersBirthYear(person);
    else
        return 0;
}
undefined
ancestry.map(mothersAgeAtBirth);
(39) [31, 0, 0, 0, 31, 0, 0, 0, 42, 0, 0, 38, 0, 28, 0, 36, 22, 39, 0, 28, 0, 29, 0, 0, 0, 20, 24, 0, 0, 29, 39, 0, 27, 35, 0, 39, 0, 0, 25]
average(ancestry.map(mothersAgeAtBirth));
14.41025641025641

stopping now.
2018-02-19 20:01:34
