http://eloquentjavascript.net/03_functions.html
2018-01-23 19:09:11
Functions
   Defining a function
   Parameters and scopes
   Nested scope
      "This approach to variable visibility is called lexical scoping.
      People who have experience with other programming languages might expect that any block of code between braces produces a new local environment. But in JavaScript, functions are the only things that create a new scope. You are allowed to use free-standing blocks.
      But the something inside the block refers to the same variable as the one outside the block. In fact, although blocks like this are allowed, they are useful only to group the body of an if statement or a loop.
      If you find this odd, you’re not alone. The next version of JavaScript will introduce a let keyword, which works like var but creates a variable that is local to the enclosing block, not the enclosing function."
   Functions as values
   Declaration notation
      function declarations are not part of the regular top-to-bottom flow of control. They are conceptually moved to the top of their scope and can be used by all the code in that scope. 
   The call stack
      Because a function has to jump back to the place of the call when it returns, the computer must remember the context from which the function was called.
      The place where the computer stores this context is the call stack. Every time a function is called, the current context is put on top of this “stack”. When the function returns, it removes the top context from the stack and uses it to continue execution.
      Storing this stack requires space in the computer’s memory. When the stack grows too big, the computer will fail with a message like “out of stack space” or “too much recursion”.
   Optional Arguments
      JavaScript is extremely broad-minded about the number of arguments you pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters simply get assigned the value undefined.
   Closure
      A function that “closes over” some local variables is called a closure.
      A good mental model is to think of the function keyword as “freezing” the code in its body and wrapping it into a package (the function value). So when you read return function(...) {...}, think of it as returning a handle to a piece of computation, frozen for later use.
   Recursion
   Growing functions
2018-01-23 20:15:33
2018-01-24 21:34:20
      Instead of lifting out the repeated part of our program wholesale, let’s try to pick out a single concept.
      A useful principle is not to add cleverness unless you are absolutely sure you’re going to need it.
   Functions and side effects
      A pure function is a specific kind of value-producing function that not only has no side effects but also doesn’t rely on side effects from other code—for example, it doesn’t read global variables that are occasionally changed by other code.
   Summary
   Exercises
      Minimum
The previous chapter introduced the standard function Math.min that returns its smallest argument. We can do that ourselves now. Write a function min that takes two arguments and returns their minimum.

// Your code here.

console.log(min(0, 10));
// → 0
console.log(min(0, -10));
// → -10


// my solution:

function myMinFunction(a, b) {
    if (a < b)
        return a;
    else
        return b;
}
undefined
console.log(myMinFunction(0,10);
VM1449:1 Uncaught SyntaxError: missing ) after argument list
console.log(myMinFunction(0,10));
VM1456:1 0
undefined
console.log(myMinFunction(0,-10));
VM1457:1 -10
undefined


      Recursion

We’ve seen that % (the remainder operator) can be used to test whether a number is even or odd by using % 2 to check whether it’s divisible by two. Here’s another way to define whether a positive whole number is even or odd:

 Zero is even.

 One is odd.

 For any other number N, its evenness is the same as N - 2.

Define a recursive function isEven corresponding to this description. The function should accept a number parameter and return a Boolean.

Test it on 50 and 75. See how it behaves on -1. Why? Can you think of a way to fix this?

// Your code here.

console.log(isEven(50));
// → true
console.log(isEven(75));
// → false
console.log(isEven(-1));
// → ??


// my solution


function isEven(isThisEven) {
    if (isThisEven < 0)
		isThisEven = -isThisEven;
	if (isThisEven > 1)
		return isEven(isThisEven -2 )
    else if (isThisEven == 0)
        return true;
	else
        return false;
}





   Bean counting
You can get the Nth character, or letter, from a string by writing "string".charAt(N), similar to how you get its length with "s".length. The returned value will be a string containing only one character (for example, "b"). The first character has position zero, which causes the last one to be found at position string.length - 1. In other words, a two-character string has length 2, and its characters have positions 0 and 1.

Write a function countBs that takes a string as its only argument and returns a number that indicates how many uppercase “B” characters are in the string.

Next, write a function called countChar that behaves like countBs, except it takes a second argument that indicates the character that is to be counted (rather than counting only uppercase “B” characters). Rewrite countBs to make use of this new function.

// Your code here.

console.log(countBs("BBC"));
// → 2
console.log(countChar("kakkerlak", "k"));
// → 4

// My soulution 1.
function countBs(howManyBsHere) {
	var thisManyBsHere = 0;
    for (counter = 0 ; counter < howManyBsHere.length; counter++){
        if (howManyBsHere.charAt(counter) == "B")
            thisManyBsHere++
    }
    return thisManyBsHere;
}
undefined
console.log(countBs("BBC"));
VM2697:1 2
undefined


// My solution 2.

function countBs(howManyBsHere) {
	var thisManyBsHere = 0;
    for (counter = 0 ; counter < howManyBsHere.length; counter++){
        if (howManyBsHere.charAt(counter) == "B")
            thisManyBsHere++
    }
    return thisManyBsHere;
}
undefined
console.log(countBs("BBC"));
VM2697:1 2
undefined

// My solution 3.
2018-01-24 22:12:51
2018-01-24 22:44:17 

function countBs(howManyBsHere) {
	return countChar(howManyBsHere, "B")
}
undefined
console.log(countBs("BBC"));
VM3126:1 2
undefined
2018-01-24 22:46:00
